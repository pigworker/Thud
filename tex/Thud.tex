\documentclass{article}
\usepackage{a4}

\newcommand{\D}[1]{\mathsf{#1}}
\newcommand{\C}[1]{\mathsf{#1}}
\newcommand{\V}[1]{\mathit{#1}}
\newcommand{\F}[1]{\mathbf{#1}}

\newcommand{\hab}{:}

\newcommand{\Tree}[1]{\D{Tree}\:#1}
\newcommand{\leaf}{\bullet}
\newcommand{\node}[2]{#1 \wedge #2}

\newcommand{\Emp}{\{\}}

\newcommand{\thud}{\mbox{`thud'}}
\newcommand{\blunder}{\mbox{`blunder'}}

\begin{document}
\title{Thud and Blunder}
\author{Conor Mc Bride and \ldots?}
\maketitle

\section{Introduction}

This is a positive little story about learning the implementations of
recursive functions on inductive data by perturbation testing,
provided the functions concerned are sufficiently unremarkable. Let me give you
an example. Consider the type $\Tree X$ of binary \emph{tree
expressions} with free variables in $X$, generated by $\leaf$ and
$\node lr$ for $l,r \hab \Tree X$. Any pair of
\[
\V{leafy}\hab \Tree{\Emp} \qquad
\V{nodey}\hab \Tree{\{\C{ll},\C{rr}\}}
\]
generates a simple structurally recursive function
\[\begin{array}{l@{\:}c@{\:}l}
\F{transform} \hab \Tree\Emp &\to& \Tree\Emp\\
\F{transform}\: \leaf & = & \V{leafy}\\
\F{transform}\: (\node lr) & = & \V{nodey}[\F{transform}\:l/\C{ll}, \F{transform}\:r/\C{rr}]
\end{array}\]
in which $\V{leafy}$ and $\V{nodey}$ act as templates, with free
variables showing where to substitute the results of the recursive
subcomputations. Now, if you have a secret function
\[
\F{mystery} \hab \Tree\Emp \to \Tree\Emp\\
\]
I have a way to choose candidates for $\V{leafy}$ and $\V{nodey}$
which will make $\F{transform}$ approximate $\F{mystery}$, and
moreover, if your $\F{mystery}$ is itself a $\F{transform}$, my
approximation will behave the same, even if I do not choose
exactly the same $\V{leafy}$ and $\V{nodey}$ as you. I can get all the
information I need by feeding the following four trees (for which I have pet names)
to $\F{mystery}$:
\[\begin{array}{r@{\,}c@{\,}l|l}
& \leaf & & \mbox{`thud'} \\
\node{\leaf&}{&\leaf} & \mbox{`blunder'} \\
\node{(\node\leaf\leaf)&}{&\leaf} & \mbox{`blunderthud'} \\
\node{\leaf&}{&(\node\leaf\leaf)} & \mbox{`thudblunder'}
\end{array}\]
Note that `blunderthud' and `thudblunder' are both generated from $\node\thud\thud$ (also known as $\blunder$) by replacing
exactly one $\thud$ with a $\blunder$.

Here is how I do it. First, I choose $\V{leafy} = \F{mystery}\:\leaf = \F{mystery}\:\thud$. So far, so good.
Next, I construct $\V{nodey}$ by exploring $\F{mystery}\:(\node\thud\thud)$ to see wherein it has my $\V{leafy}$ but $\F{mystery}\:\mbox{`blunderthud'}$ or from $\F{mystery}\:\mbox{`thudblunder'}$ do not These are the telltale signs that replacing $\thud$ by $\blunder$ has made a difference. I place $\C{ll}$ to mark discrepancy with $\F{mystery}\:\mbox{`blunderthud'}$ and, otherwise, $\C{rr}$ to mark discrepancy with $\F{mystery}\:\mbox{`thudblunder'}$. I am now sure that my $\F{transform}$ and your $\F{mystery}$ agree on both $\thud$ and $\blunder$, at least, even if they differ elsewhere: there are plenty of $\F{mystery}$ functions which are not $\F{transform}s$, and they may very well do so.

But I promise you that if your $\F{mystery}$ \emph{is} a $\F{transform}$ and it fails to distinguish $\thud$ from $\blunder$, then it is constant, and if it \emph{does} tell them apart, then I shall indeed compute exactly the $\V{leafy}$ and $\V{nodey}$ you chose!


\end{document}
